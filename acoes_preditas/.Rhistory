col <- colunas[53]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
col <- colunas[54]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
true_retornos = retornos[(ns + 1):length(retornos)]
predicoes <- data.frame(AR = AR_1, SETAR = SETAR, LSTAR = LSTAR, TRUE_RETORNO = true_retornos, ACF = acf, BDS = bds)
write_csv(predicoes, paste0("Previsao_", col, ".csv"))
col <- colunas[55]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
true_retornos = retornos[(ns + 1):length(retornos)]
predicoes <- data.frame(AR = AR_1, SETAR = SETAR, LSTAR = LSTAR, TRUE_RETORNO = true_retornos, ACF = acf, BDS = bds)
write_csv(predicoes, paste0("Previsao_", col, ".csv"))
col <- colunas[56]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
true_retornos = retornos[(ns + 1):length(retornos)]
predicoes <- data.frame(AR = AR_1, SETAR = SETAR, LSTAR = LSTAR, TRUE_RETORNO = true_retornos, ACF = acf, BDS = bds)
write_csv(predicoes, paste0("Previsao_", col, ".csv"))
col <- colunas[57]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
col <- colunas[58]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
col <- colunas[59]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
col <- colunas[60]
df <- dados %>% select("Data", col)
#df[col][df[col] == "-"] <- NA
df <- df %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100*log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
#Window size
ws <- floor(length(retornos)*0.3)
#Vetores que conterao as previsoes
AR_1 = numeric(length = ws)
SETAR = numeric(length = ws)
LSTAR = numeric(length = ws)
# Vetores com os resultados dos testes
bds <-numeric(length = ws)
acf <- numeric(length = ws)
for (i in 0:(ws - 1)){
cat("Iteração: ", i+1, "\n")
ns = length(retornos) - ws #new size
r = retornos[1 + i:ns + i]
ar = arima(r, order = c(1, 0, 0))
pred_ar = predict(ar, n.ahead = 1)[1]
AR_1[1+i] = unlist(pred_ar)
setr = tsDyn::setar(r, m = 2, thDelay = 1,
trace = TRUE, include = "const", common = "none")
pred_setar = predict(setr, n.ahead = 1)[1]
SETAR[i+1] = pred_setar
lstr = tsDyn::lstar(r, trace  = TRUE, include = "const", m = 2,
thDelay = 1)
pred_lstar = predict(lstr, n.ahead = 1)[1]
LSTAR[i+1] <- pred_lstar
acf[i + 1] <- verifica_primeiro_acf(r)
bds[i + 1] <- bds_test_majority(r)
}
true_retornos = retornos[(ns + 1):length(retornos)]
predicoes <- data.frame(AR = AR_1, SETAR = SETAR, LSTAR = LSTAR, TRUE_RETORNO = true_retornos, ACF = acf, BDS = bds)
write_csv(predicoes, paste0("Previsao_", col, ".csv"))
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(tsDyn)
library(forecast)
library(aTSA)
library(tseries)
for (j in 301:length(colunas)) { #Indice atual é
indice_atual = j
cat("Indice atual é ", indice_atual, "\n")
col <- colunas[j]
df <- dados %>% select("Data", col) %>% as_tibble()
df[[col]] <- as.double(df[[col]])
df <- df %>% drop_na()
df$Return <- 100 * log(df[[col]] / lag(df[[col]]))
df <- df[-1,]
retornos <- na.omit(df$Return)
ws <- floor(length(retornos) * 0.3)
AR_1 <- numeric(length = ws)
SETAR <- numeric(length = ws)
LSTAR <- numeric(length = ws)
bds <- numeric(length = ws)
acf <- numeric(length = ws)
error_occurred <- FALSE
for (i in 0:(ws - 1)) {
if (error_occurred) break
cat("Iteração: ", i + 1, "\n")
ns <- length(retornos) - ws
r <- retornos[1 + i:ns + i]
ar <- arima(r, order = c(1, 0, 0))
pred_ar <- predict(ar, n.ahead = 1)[1]
AR_1[1 + i] <- unlist(pred_ar)
# Try-Catch for SETAR
setar_result <- tryCatch({
setr <- tsDyn::setar(r, m = 2, thDelay = 1, trace = TRUE, include = "const", common = "none")
predict(setr, n.ahead = 1)[1]
}, error = function(e) {
message("Error in SETAR: ", e$message)
error_occurred <<- TRUE
return(NA)
})
if (error_occurred) break
SETAR[1 + i] <- setar_result
# Try-Catch for LSTAR
lstar_result <- tryCatch({
lstr <- tsDyn::lstar(r, trace = TRUE, include = "const", m = 2, thDelay = 1)
predict(lstr, n.ahead = 1)[1]
}, error = function(e) {
message("Error in LSTAR: ", e$message)
error_occurred <<- TRUE
return(NA)
})
if (error_occurred) break
LSTAR[1 + i] <- lstar_result
acf[1 + i] <- verifica_primeiro_acf(r)
bds[1 + i] <- bds_test_majority(r)
}
if (error_occurred){
cat("Houve um problema de covergência no lstar() ou setar() \n")
next
}
true_retornos <- retornos[(ns + 1):length(retornos)]
predicoes <- data.frame(AR = AR_1, SETAR = SETAR, LSTAR = LSTAR, TRUE_RETORNO = true_retornos, ACF = acf, BDS = bds)
write_csv(predicoes, paste0("Previsao_", col, ".csv"))
}
df_FCF <- dados["FCF"]
View(df_FCF)
predicao_FCF <- read.csv("Previsao_FCF.csv")
predicao_FCF <- read.csv("acoes_preditas_2/Previsao_FCF.csv")
setwd("~/Documentos/IC/Codigo/Previsao/Expandido/acoes_preditas_2")
predicao_FCF <- read.csv("Previsao_FCF.csv")
View(predicao_FCF)
predicao_FCF <- predicao_FCF %>% as_tibble()
library(tidyverse)
library(TSA) # Pacote para o modelo SETAR
library(tsDyn) # Pacote para o modelo LSTAR
View(predicao_FCF)
df_FCF <- df_FCF %>% as_tibble()
df_FCF[["FCF"]] <- as.double(df_FCF[["FCF"]])
df_FCF <- df_FCF %>% drop_na()
df_FCF$Return <- 100 * log(df_FCF[["FCF"]] / lag(df_FCF[["FCF"]]))
df <- df[-1,]
retornos <- na.omit(df_FCF$Return)
ws <- floor(length(retornos) * 0.3)
retornos <- retornos[1, ws - 1]
ns <- length(retornos) - ws
retornos <- retornos[1, ns - 1]
retornos <- retornos[1, (ns - 1)]
r <- retornos[1, ns]
r <- retornos[1:ns]
# Função para plotar gráficos de resíduos
plot_residuals <- function(model, title) {
residuals <- residuals(model)
par(mfrow = c(2, 2))
# Resíduos
plot(residuals, main = paste("Resíduos", title))
# ACF dos resíduos
acf(residuals, main = paste("ACF dos Resíduos", title))
# Histograma dos resíduos
hist(residuals, main = paste("Histograma dos Resíduos", title), breaks = 20)
# Q-Q plot dos resíduos
qqnorm(residuals, main = paste("Q-Q Plot dos Resíduos", title))
qqline(residuals)
}
tryCatch({
# Modelo ARMA
model_ar <- arima(r, p = 1, d = 0, q = 0)
plot_residuals(model_arma$fit, title = paste("AR(", 1,  ")"))
# Modelo SETAR
model_setar <- setar(r, m = 2)
plot_residuals(model_setar, title = paste("SETAR(", 2, ")"))
# Modelo LSTAR
model_lstar <- lstar(r, m = 2)
plot_residuals(model_lstar, title = paste("LSTAR(", 2, ")"))
}, error = function(e) {
cat("Erro para p =", 1, "q =", 0, ": ", conditionMessage(e), "\n")
})
# Modelo ARMA
model_ar <- arima(r, p = 1, d = 0, q = 0)
plot_residuals(model_arma$fit, title = paste("AR(", 1,  ")"))
# Modelo ARMA
model_ar <- arima(r, p = 1, d = 0, q = 0)
# Modelo ARMA
model_ar <- arima(r, order = c(1, 0, 0))
plot_residuals(model_ar$fit, title = paste("AR(", 1,  ")"))
# Modelo ARMA
model_ar <- sarima(r, p = 1, d = 0, q = 0)
library(astsa)
# Modelo ARMA
model_ar <- sarima(r, p = 1, d = 0, q = 0)
# Modelo SETAR
model_setar <- setar(r, m = 2)
plot_residuals(model_setar, title = paste("SETAR(", 2, ")"))
residuals <- residuals(model_setar$fitted.values)
View(model_setar)
View(model_setar)
residuals <- residuals(model_setar$fitted.values)
acf(model_setar$residuals)
qqnorm(model_setar$residuals, main = paste("Q-Q Plot dos Resíduos", title))
qqline(model_setar$residuals)
p_values <- sapply(1:20, function(lag) {
Box.test(model_setar$residuals, lag = lag, type = "Ljung-Box")$p.value
})
abline(h = 0.05, col = "blue", lty = 2)  # Significance level line at 0.05
# Plot the p-values for the Ljung-Box test
plot(1:20, p_values, type = "b", pch = 19, col = "black",
xlab = "Lag", ylab = "p-value",
main = "Ljung-Box Test p-values for Residuals")
abline(h = 0.05, col = "blue", lty = 2)  # Significance level line at 0.05
# Modelo ARMA
model_ar <- sarima(r, p = 1, d = 0, q = 0)
fit <- SETAR(r, m=2, d=1)
library(tsDyn)
fit <- SETAR(r, m=2, d=1)
fit <- tsDyn::SETAR(r, m=2, d=1)
fit <- tsDyn::setar(r, m=2, d=1)
# Extract residuals
residuals <- residuals(fit)
# Define the maximum number of lags for the Ljung-Box test
max_lag <- 20
# Perform the Ljung-Box test for each lag and store p-values
p_values <- sapply(1:max_lag, function(lag) {
test <- Box.test(residuals, lag=lag, type="Ljung-Box")
test$p.value
})
# Create a data frame for plotting
p_values_df <- data.frame(
Lag = 1:max_lag,
P_Value = p_values
)
# Plot p-values
ggplot(p_values_df, aes(x=Lag, y=P_Value)) +
geom_line() +
geom_point() +
labs(title="Ljung-Box Test P-values for SETAR Residuals",
x="Lag",
y="P-Value") +
theme_minimal() +
geom_hline(yintercept=0.05, linetype="dashed", color="red")
# Plot p-values
ggplot(p_values_df, aes(x=Lag, y=P_Value)) +
geom_point(shape=21, color="blue", fill="white", size=3, stroke=1) +
labs(title="Ljung-Box Test P-values for SETAR Residuals",
x="Lag",
y="P-Value") +
theme_minimal() +
geom_hline(yintercept=0.05, linetype="dashed", color="red")
# Plot p-values
ggplot(p_values_df, aes(x=Lag, y=P_Value)) +
geom_point(shape=21, color="blue", fill="white", size=1, stroke=1) +
labs(title="Ljung-Box Test P-values for SETAR Residuals",
x="Lag",
y="P-Value") +
theme_minimal() +
geom_hline(yintercept=0.05, linetype="dashed", color="red")
# Plot p-values
ggplot(p_values_df, aes(x=Lag, y=P_Value)) +
geom_point(shape=21, color="blue", fill="white", size=2, stroke=1) +
labs(title="Ljung-Box Test P-values for SETAR Residuals",
x="Lag",
y="P-Value") +
theme_minimal() +
geom_hline(yintercept=0.05, linetype="dashed", color="red")
# Plot p-values
ggplot(p_values_df, aes(x=Lag, y=P_Value)) +
geom_point(shape=21, color="black", fill="white", size=2, stroke=1) +
labs(title="Ljung-Box Test P-values for SETAR Residuals",
x="Lag",
y="P-Value") +
theme_minimal() +
geom_hline(yintercept=0.05, linetype="dashed", color="blue")
